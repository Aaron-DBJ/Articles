

[TOC]

# ä¸€ã€æ¶ˆæ¯æœºåˆ¶åŸç†

Handleræ¶ˆæ¯æœºåˆ¶è€ç”Ÿå¸¸è°ˆäº†ï¼Œå¿…å¤‡å…«è‚¡ä¹‹ä¸€ã€‚ä½†æ˜¯æ¯æ¬¡çœ‹éƒ½æœ‰æ–°æ”¶è·ï¼Œæ•…å¥½å¥½æ€»ç»“ä¸€ä¸‹Handlerç›¸å…³çŸ¥è¯†ã€‚

## 1.1 åŸºæœ¬æ¦‚å¿µ

### 1ã€Handler

ç”¨äºå‘é€å’Œå¤„ç†æ¶ˆæ¯çš„ç±»ï¼Œæœ‰å¤šç§é‡è½½çš„æ„é€ æ–¹æ³•ï¼Œé€šè¿‡ä¸€ç³»åˆ—`sendXXX`å’Œ`postXXX`æ–¹æ³•æ¥å‘é€æ¶ˆæ¯åˆ°æ¶ˆæ¯é˜Ÿåˆ—ï¼Œç„¶åé€šè¿‡å®ç°`Handler.Callback`æ¥å£æˆ–é‡å†™`handleMessage`æ–¹æ³•å¤„ç†æ¶ˆæ¯

### 2ã€MessageQueue

æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå®ƒæ˜¯ä¸€ä¸ªé“¾è¡¨ç»“æ„ï¼Œç”¨ä»¥å­˜æ”¾handlerå‘é€çš„æ¶ˆæ¯ï¼Œå®ç°äº†è·å–æ¶ˆæ¯çš„æ–¹æ³•`next()`å’Œç§»é™¤æ¶ˆæ¯åŠæ¶ˆæ¯å¤„ç†å›è°ƒçš„æ–¹æ³•ï¼ˆ`removeXXX`ç³»åˆ—æ–¹æ³•)

### 3ã€Message

æ¶ˆæ¯ï¼Œæ‰¿è½½ä¸€äº›åŸºæœ¬æ•°æ®ï¼Œæ¶ˆæ¯é˜Ÿåˆ—å­˜æ”¾å¯¹è±¡ã€‚ç»´æŠ¤äº†ä¸€ä¸ªæ¶ˆæ¯å¯¹è±¡æ± ï¼Œå¯ä»¥å¤ç”¨æ¶ˆæ¯ï¼Œé¿å…åˆ›å»ºå¤ªå¤šæ¶ˆæ¯å¯¹è±¡å ç”¨è¿‡å¤šå†…å­˜ï¼Œå¯¼è‡´APPå¡é¡¿ã€‚

æ¶ˆæ¯åˆ†ç±»ï¼š

![image-20210420173150919](/Users/mtdp/Library/Application Support/typora-user-images/image-20210420173150919.png)

### 4ã€Looper

æ¶ˆæ¯æœºåˆ¶çš„çµé­‚ï¼Œç”¨ä»¥ä¸æ–­è°ƒåº¦æ¶ˆæ¯å¯¹è±¡å¹¶ä¸”åˆ†å‘ç»™handlerå¤„ç†ã€‚Looperæ˜¯åŒçº¿ç¨‹ç»‘å®šçš„ï¼Œä¸åŒçº¿ç¨‹çš„Looperä¸ä¸€æ ·ï¼Œé€šè¿‡ThreadLocalå®ç°çº¿ç¨‹éš”ç¦»ã€‚

## 1.2 æ¶ˆæ¯æœºåˆ¶ä¸»æµç¨‹

### 1ã€å‘é€æ¶ˆæ¯

![image-20210420174733905](/Users/mtdp/Library/Application Support/typora-user-images/image-20210420174733905.png)

å¯ä»¥ä½¿ç”¨sendMessageï¼ˆä»¥åŠä¸€ç³»åˆ— sendXXXçš„æ¶ˆæ¯å‘é€æ–¹æ³•ï¼‰å’Œpostæ–¹æ³•å‘é€å³æ—¶åŒæ­¥æ¶ˆæ¯ï¼Œæˆ–é€šè¿‡sendXXXDelayedå’ŒpostDelayedå‘é€å»¶è¿ŸåŒæ­¥æ¶ˆæ¯ã€‚

å¦‚æœæ˜¯é€šè¿‡sendXXXæ–¹æ³•å‘é€å³æ—¶æˆ–å»¶æ—¶æ¶ˆæ¯ï¼Œæœ€ç»ˆéƒ½ä¼šè¾—è½¬è°ƒç”¨åˆ°`sendMessageAtTime(@NonNull Message msg, long uptimeMillis)`æ–¹æ³•ï¼Œç„¶åè°ƒç”¨`enqueueMessage`æ–¹æ³•ã€‚

```java
private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,
            long uptimeMillis) {
        msg.target = this;// â‘  è®¾ç½®å¤„ç†è¯¥æ¶ˆæ¯çš„handlerå¯¹è±¡
        msg.workSourceUid = ThreadLocalWorkSource.getUid();
		// â‘¡ è®¾ç½®æ¶ˆæ¯ç±»å‹ï¼ŒåŒæ­¥æˆ–å¼‚æ­¥
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
  	    // â‘¢ äº¤ç”±æ¶ˆæ¯é˜Ÿåˆ—çš„å…¥é˜Ÿæ–¹æ³•
        return queue.enqueueMessage(msg, uptimeMillis);
    }
```

è¯¥æ–¹æ³•ä¸»è¦æœ‰3ä¸ªä½œç”¨ï¼Œæ³¨é‡Šä¸­çš„â‘ â‘¡â‘¢åˆ†åˆ«è¯´æ˜äº†ã€‚

### 2ã€æ¶ˆæ¯å…¥é˜Ÿ

æ¶ˆæ¯å…¥é˜Ÿæœ€ç»ˆæ˜¯é æ¶ˆæ¯é˜Ÿåˆ—çš„enqueueMessageæ–¹æ³•å®Œæˆï¼Œå…¶ä»£ç å¦‚ä¸‹

```java
boolean enqueueMessage(Message msg, long when) {
  		// â‘ 
        if (msg.target == null) {
            throw new IllegalArgumentException("Message must have a target.");
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + " This message is already in use.");
        }

        synchronized (this) {
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + " sending message to a Handler on a dead thread");
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }
			// â‘¡
            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
          	// â‘¢
            if (p == null || when == 0 || when < p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                // â‘£
                needWake = mBlocked && p.target == null && msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when < p.when) {
                        break;
                    }
                    if (needWake && p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

			// â‘¤
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
```

æ³¨é‡Šä¸­æ ‡æ˜äº†5ä¸ªæ³¨æ„ç‚¹ï¼ŒğŸ‘‡ä¸€ä¸€è¯´æ˜ä¸‹ï¼š

â‘  æ¶ˆæ¯å¯¹è±¡å¿…é¡»æŒ‡å®š`target`ï¼Œä¹Ÿå°±æ˜¯å¤„ç†æ¶ˆæ¯çš„handlerå¯¹è±¡ï¼›è€Œä¸”messageå¯¹è±¡çš„`flag`ä¸º`FLAG_IN_USE`ã€‚å¦åˆ™å°†æŠ›å‡ºå¼‚å¸¸ã€‚

â‘¡è®¾ç½®æ¶ˆæ¯å¯¹è±¡æ ‡å¿—`FLAG_IN_USE`å’Œæ—¶é—´ï¼Œåˆ›å»ºå”¤é†’å­—æ®µï¼Œç”¨äºæ ‡è®°æ˜¯å¦éœ€è¦å”¤é†’æ¶ˆæ¯é˜Ÿåˆ—

â‘¢å¦‚æœå½“å‰æ¶ˆæ¯é˜Ÿåˆ—æ²¡æœ‰æ¶ˆæ¯æˆ–è¦å…¥é˜Ÿçš„æ¶ˆæ¯`when`å€¼å°äºå¯¹åˆ—å¤´æ¶ˆæ¯`when`å€¼ï¼Œåˆ™å°†æ–°æ¶ˆæ¯æ’å…¥åˆ°é“¾è¡¨å¤´éƒ¨ã€‚è®¾ç½®`needWeak`ï¼Œå®ƒåˆç”±`mBlocked`å˜é‡å†³å®šï¼Œ`mBlocked`çš„è®¾ç½®æ˜¯åœ¨`next()`æ–¹æ³•ä¸­ï¼Œ**ç®€å•æ¥è¯´æ¶ˆæ¯é˜Ÿåˆ—ä»…æœ‰å»¶æ—¶æ¶ˆæ¯æˆ–ä¸ºç©ºé˜Ÿåˆ—æ—¶ï¼Œ`mBlocked`ä¸º`true`**

â‘£ä¸æ»¡è¶³â‘¢çš„æƒ…å†µä¸‹ï¼Œä»æ¶ˆæ¯é“¾è¡¨å¤´å¼€å§‹éå†ï¼Œå°†æ–°æ¶ˆæ¯æ’å…¥åˆ°ç¬¬ä¸€ä¸ªwhenå€¼å¤§äºæ–°æ¶ˆæ¯whenå€¼çš„æ¶ˆæ¯èŠ‚ç‚¹å‰æ–¹ã€‚

ä¾‹å¦‚å½“å‰æ¶ˆæ¯é˜Ÿé‡Œï¼š100 - 30 -20 -10ï¼ˆæ•°å­—è¡¨ç¤ºæ¶ˆæ¯çš„whenå€¼ï¼‰

```mermaid
graph LR
A((100))
B((30))
C((20))
D((10))
A --- B --- C --- D
```

ç°è¦æ’å…¥ä¸€ä¸ªæ–°æ¶ˆæ¯50ï¼Œé‚£ä¹ˆæ’å…¥åçš„é˜Ÿåˆ—æƒ…å†µæ˜¯ï¼š

```mermaid
graph LR
A((100))
B((30))
C((20))
D((10))
E((50))
A --- E --- B --- C --- D
```



â‘¤æ˜¯å¦éœ€è¦å”¤é†’ï¼Œéœ€è¦åˆ™è°ƒç”¨nativeæ–¹æ³•å”¤é†’

æ€»ä¹‹ï¼Œ**å…¥é˜Ÿæ–¹æ³•å°±æ˜¯è®©æ‰€æœ‰æ¶ˆæ¯æ ¹æ®whençš„å¤§å°å°½é‡æœ‰åºæ’åˆ—ï¼Œwhenè¶Šå°åˆ™è¶Šä½äºæ¶ˆæ¯é“¾è¡¨å¤´éƒ¨**ã€‚

### 3ã€æ¶ˆæ¯å‡ºé˜Ÿ

Looperçš„`loop()`åœ¨ä¸€ä¸ªæ­»å¾ªç¯ä¸­ä¸æ–­è·å–æ¶ˆæ¯ï¼Œè·å–åˆ°æ¶ˆæ¯å°±åˆ†å‘ç»™handlerå¤„ç†ï¼Œè·å–æ¶ˆæ¯é€šè¿‡`MessageQueue#next()`æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•é€»è¾‘è¾ƒå¤šä¸”éƒ½æ¯”è¾ƒé‡è¦ï¼Œä¸‹é¢ä¼šè¯¦ç»†è¯´æ˜ã€‚

```java
 Message next() {
        ......
		// â‘ 
        int pendingIdleHandlerCount = -1; // -1 only during first iteration
   		// â‘¡
        int nextPollTimeoutMillis = 0;
        for (;;) {
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }
			// â‘¢
            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
              	// â‘£
                if (msg != null && msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null && !msg.isAsynchronous());
                }
              	// â‘¤
                if (msg != null) {
                    if (now < msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // Got a message.
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }

                // Process the quit message now that all pending messages have been handled.
                if (mQuitting) {
                    dispose();
                    return null;
                }

                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
              	// â‘¥
                if (pendingIdleHandlerCount < 0
                        && (mMessages == null || now < mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount <= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    mBlocked = true;
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            for (int i = 0; i < pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler
                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG, "IdleHandler threw exception", t);
                }

                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }
			// â‘¦
            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;
            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            nextPollTimeoutMillis = 0;
        }
    }
```

â‘  `pendingIdleHandlerCount`è¡¨ç¤ºIdleHandlerçš„æ•°é‡ã€‚

â‘¡ `nextPollTimeoutMillis`è¡¨ç¤ºæ¶ˆæ¯é˜Ÿåˆ—ä¼‘çœ çš„æ—¶é—´ï¼Œæ˜¯ä¸ªé˜»å¡æ–¹æ³•ã€‚ -1è¡¨ç¤ºæ— é™é˜»å¡ï¼Œ0è¡¨ç¤ºä¸é˜»å¡

â‘¢ å®ç°é˜»å¡çš„nativeæ–¹æ³•ï¼Œå¯é€šè¿‡`nativeWake`æ–¹æ³•å”¤é†’

â‘£ é’ˆå¯¹**åŒæ­¥å±éšœæœºåˆ¶çš„å¤„ç†**ï¼Œå‰æ–‡å·²ç»è¯´äº†æ™®é€šæ¶ˆæ¯åœ¨å…¥é˜Ÿå‰ä¸€å®šä¼šè®¾ç½®`target`å±æ€§ï¼Œå”¯ç‹¬æœ‰ç§æ–¹å¼ä¸ä¼šï¼Œå³`postSyncBarrier`æ–¹æ³•å‘å‡ºçš„åŒæ­¥å±éšœæ¶ˆæ¯æ˜¯ä¸ä¼šè®¾ç½®`target`å±æ€§çš„ï¼ŒåŒæ­¥å±éšœç›¸å…³å†…å®¹åé¢ä¼šè¯¦ç»†ä»‹ç»ï¼Œè¿™é‡Œåªè¦äº†è§£æ™®é€šçš„åŒæ­¥æ¶ˆæ¯ä¸ä¼šèµ°åˆ°è¿™æ­¥å³å¯ã€‚

â‘¤ å¯¹äºåŒæ­¥æ¶ˆæ¯ï¼Œä»æ­¤æ­¥å¼€å§‹çœŸæ­£å»è·å–æ¶ˆæ¯å¯¹è±¡ã€‚é¦–å…ˆæ˜ç¡®ä¸‹ä»£ç é‡Œçš„å‡ ä¸ªå¯¹è±¡å«ä¹‰ï¼š`mMessage`å§‹ç»ˆè¡¨ç¤ºæ¶ˆæ¯é“¾è¡¨å¤´éƒ¨ï¼Œ`p`è¡¨ç¤ºå½“å‰èŠ‚ç‚¹ï¼Œ`prevMsg`è¡¨ç¤º`p`èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚

- å¯¹äºå³æ—¶æ¶ˆæ¯ï¼Œè®¾ç½®`mBlocked=false`ï¼Œè¡¨ç¤ºä¸é˜»å¡ã€‚åŒæ­¥æ¶ˆæ¯çš„`prevMsg`å§‹ç»ˆä¸ºnullï¼Œæ‰€ä»¥ä»å¤´ç»“ç‚¹å¼€å§‹éå†ï¼Œè·å–å½“å‰èŠ‚ç‚¹å¹¶è¿”å›ã€‚

- å¯¹äºå»¶æ—¶æ¶ˆæ¯ï¼Œè®¡ç®—å»¶æ—¶æ—¶é—´ï¼Œç„¶åèµ°åˆ°â‘¥ï¼Œè‹¥`now < mMessages.when`è¡¨ç¤ºè¿˜æ²¡åˆ°å»¶æ—¶æ¶ˆæ¯æ‰§è¡Œæ—¶é—´ï¼Œç„¶åä¼šèµ°åˆ°`if(pendingIdleHandlerCount <= 0ï¼‰`ä¸­ï¼Œè®¾ç½®`mBlocked=true`ï¼Œç„¶åå¼€å§‹ä¸‹æ¬¡å¾ªç¯ï¼Œåˆèµ°åˆ°â‘¢å¤„ï¼Œ`nextPollTimeoutMillis`ä¸ç­‰äº0ï¼Œäºæ˜¯é˜»å¡ã€‚

â‘¥ ç”¨äºè®¡ç®—`IdleHandler`ä¸ªæ•°ï¼Œåˆå§‹åŒ–`IdleHandler`æ•°ç»„ã€‚`IdleHandler`æ˜¯ç”¨äºåœ¨æ¶ˆæ¯é˜Ÿåˆ—ç©ºé—²æ—¶å¤„ç†ä¸€äº›ä»»åŠ¡ï¼Œé€‚ç”¨äºä¸€äº›ä¸ç´§æ€¥éé«˜ä¼˜çš„ä»»åŠ¡ï¼Œåé¢ä¹Ÿä¼šè¯¦ç»†ä»‹ç»ã€‚

â‘¦ é‡ç½®`pendingIdleHandlerCount`å’Œ`nextPollTimeoutMillis`

### 4ã€æ¶ˆæ¯åˆ†å‘

å‰æ–‡è¯´äº†Looperçš„`loop`æ–¹æ³•ä¸æ–­è·å–æ¶ˆæ¯å¹¶åˆ†å‘ï¼Œåˆ†å‘çš„å…³é”®ä»£ç å°±æ˜¯

```java
public static void loop() {
				......
        for (;;) {
          	// â‘ 
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            // This must be in a local variable, in case a UI event sets the logger
          	//â‘¡
            final Printer logging = me.mLogging;
            if (logging != null) {
                logging.println(">>>>> Dispatching to " + msg.target + " " +
                        msg.callback + ": " + msg.what);
            }
            // Make sure the observer won't change while processing a transaction.
            final Observer observer = sObserver;
						......
            try {
              	// â‘¢
                msg.target.dispatchMessage(msg);
                if (observer != null) {
                    observer.messageDispatched(token, msg);
                }
                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
            } catch (Exception exception) {
                if (observer != null) {
                    observer.dispatchingThrewException(token, msg, exception);
                }
                throw exception;
            } finally {
                ThreadLocalWorkSource.restore(origWorkSource);
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }
           	......
           	// â‘£
            msg.recycleUnchecked();
        }
    }
```

â‘  è·å–Looperå¯¹è±¡ï¼Œå¦‚æœä¸ºç©ºçš„è¯æŠ›å‡ºå¼‚å¸¸ã€‚

â‘¡ å¯ä»¥é€šè¿‡`Looper#setMessageLogging`æ–¹æ³•è®¾ç½®æ‰“å°å™¨ï¼Œç”¨æ¥è¾“å‡ºä¸€äº›å¼€å‘è€…éœ€è¦çš„ä¿¡æ¯ï¼Œé€šå¸¸åœ¨æ€§èƒ½ç›‘æ§ä¸Šéœ€è¦è·å–è¿™äº›ä¿¡æ¯æ¥è¯„ä¼°ä¼˜åŒ–æ•ˆæœã€‚

â‘¢ åˆ†å‘æ¶ˆæ¯ç»™handlerå¤„ç†ï¼Œ`target`å°±æ˜¯åœ¨æ¶ˆæ¯å…¥é˜Ÿæ—¶è®¾ç½®çš„handlerå¯¹è±¡ã€‚

â‘£ å›æ”¶æ¶ˆæ¯å¯¹è±¡

æ­¥éª¤â‘¢å°†æ¶ˆæ¯åˆ†å‘ç»™äº†å¯¹åº”handlerï¼Œçœ‹ä¸‹`dispatchMessage`æ–¹æ³•çš„å®ç°

```java
public void dispatchMessage(@NonNull Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
```

ä»£ç å¾ˆæ¸…æ™°ï¼Œé¦–å…ˆå¦‚æœè®¾ç½®`msg.callback`ï¼Œå°±è°ƒç”¨`handleCallback`æ–¹æ³•ã€‚é‚£ä¹ˆ`msg.callback`åœ¨å“ªé‡Œè®¾ç½®çš„å‘¢ï¼Ÿæ‰¾åˆ°èµ‹å€¼çš„åœ°æ–¹ï¼Œå‘ç°`post`å’Œ`postDelayed`æ–¹æ³•

```java
public final boolean post(@NonNull Runnable r) {
       return  sendMessageDelayed(getPostMessage(r), 0);
    }
```

ä¼ å…¥äº†`getPostMessage`æ–¹æ³•ï¼Œç»§ç»­çœ‹è¯¥æ–¹æ³•

```java
private static Message getPostMessage(Runnable r) {
        Message m = Message.obtain();
        m.callback = r;
        return m;
    }
```

ç°åœ¨æ˜äº†äº†ï¼Œæ­£æ˜¯è¿™é‡Œè®¾ç½®äº†`msg.callback`ï¼Œå¹¶ä¸”å€¼å°±æ˜¯postçš„å‚æ•°ï¼Œä¸€ä¸ªrunnableå¯¹è±¡ã€‚

çœ‹ä¸‹`handleCallback`ä»£ç 

```java
private static void handleCallback(Message message) {
        message.callback.run();
    }
```

å…¶å®å°±æ˜¯æ‰§è¡Œäº†postä¼ å…¥çš„runnableå‚æ•°çš„runæ–¹æ³•ã€‚

å¦‚æœä¸æ˜¯é€šè¿‡postæ–¹å¼å‘é€çš„æ¶ˆæ¯ï¼Œå°±ä¼šèµ°åˆ°elseé€»è¾‘é‡Œã€‚é¦–å…ˆåˆ¤æ–­æ˜¯å¦å®ç°äº†`Handler.Callback`æ¥å£ï¼Œå¯åœ¨handlerçš„æ„é€ å‡½æ•°ä¼ å…¥ï¼Œè®¾ç½®äº†åˆ™è°ƒç”¨`Handler.Callback`æ¥å£çš„`handleMessage`æ–¹æ³•ã€‚

å¦åˆ™è°ƒç”¨`Handler`çš„`handleMessage`æ–¹æ³•ï¼Œå®ƒæ˜¯ä¸€ä¸ªç©ºæ–¹æ³•ï¼Œéœ€è¦å¼€å‘è€…é‡å†™æ¥å®ç°ä¸šåŠ¡é€»è¾‘ã€‚

æ€»ç»“ï¼š**æ¶ˆæ¯çš„åˆ†å‘æ‰§è¡Œé¡ºåºå°±æ˜¯`post#run`æ–¹æ³• -> `Handler.Callback.handlerMessage`æ–¹æ³• -> `Handler#handlerMessage`æ–¹æ³•**

è‡³æ­¤ï¼ŒHandleræ¶ˆæ¯çš„å‘é€ã€å…¥é˜Ÿå‡ºé˜Ÿã€ä»¥åŠåˆ†å‘æ‰§è¡Œçš„å…¨æµç¨‹å°±é˜è¿°å®Œæ¯•äº†ï¼Œè·¯å¾„è¿˜æ˜¯å¾ˆæ¸…æ™°çš„ã€‚ä½†æ˜¯ä¾ç„¶é—ç•™äº†ä¸€äº›é—®é¢˜ï¼Œæ¯”å¦‚åŒæ­¥å±éšœã€IdleHandlerç­‰ï¼Œæ‰€ä»¥æˆ‘ä»¬ç»§ç»­ï¼ˆ:dog:ï¼‰ã€‚

# äºŒã€åŒæ­¥å±éšœ

æˆ‘ä»¬çŸ¥é“æ— è®ºæ˜¯åº”ç”¨å¯åŠ¨è¿˜æ˜¯å±å¹•åˆ·æ–°éƒ½éœ€è¦å®Œæ•´ç»˜åˆ¶æ•´ä¸ªé¡µé¢å†…å®¹ï¼Œç›®å‰å¤§å¤šæ•°æ‰‹æœºçš„å±å¹•åˆ·æ–°ç‡ä¸º60Hzï¼Œä¹Ÿå°±æ˜¯è€³ç†Ÿèƒ½è¯¦çš„16msåˆ·æ–°ä¸€æ¬¡å±å¹•ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œå¦‚æœä¸»çº¿ç¨‹çš„æ¶ˆæ¯é˜Ÿåˆ—å¾…æ‰§è¡Œçš„æ¶ˆæ¯éå¸¸å¤šï¼Œæ€ä¹ˆèƒ½ä¿è¯ç»˜åˆ¶é¡µé¢çš„æ¶ˆæ¯ä¼˜å…ˆå¾—åˆ°æ‰§è¡Œï¼Œæ¥å°½åŠ›ä¿è¯ä¸å¡é¡¿å‘¢ã€‚

å‰æ–‡åˆ†æäº†æ•´ä¸ªæ¶ˆæ¯ä¼ é€’å¤„ç†æœºåˆ¶ï¼Œæœ‰ä¸€ä¸ªå¯ç–‘åœ°æ–¹ï¼Œå°±æ˜¯åœ¨å–æ¶ˆæ¯æ—¶ã€‚2ä¸ªç–‘ç‚¹

- æ¶ˆæ¯çš„targetå±æ€§ä¸ºnull
- æ¶ˆæ¯è¢«è®¾ç½®ä¸ºäº†å¼‚æ­¥æ¶ˆæ¯

```java
				...... 								
				final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
              	// *
                if (msg != null && msg.target == null) {
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null && !msg.isAsynchronous());
                }

                if (msg != null) {
                    if (now < msg.when) {
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                      	......
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }
```

åœ¨æ ‡*å¤„ï¼Œæœ‰ä¸ªå¾ªç¯ä¸æ–­è¿‡æ»¤æ‰åŒæ­¥æ¶ˆæ¯ï¼Œå‘ç°è¿›å…¥æ¡ä»¶æ˜¯targetå¯¹è±¡ä¸ºnullï¼Œè€Œæ­£å¸¸æƒ…å†µä¸‹å…¥é˜Ÿçš„æ¶ˆæ¯éƒ½ä¼šè®¾ç½®targetã€‚

ä»åº”ç”¨å¯åŠ¨å…¥æ‰‹ï¼Œé¡µé¢å¯åŠ¨è¿‡ç¨‹ä¸è¯¦è¿°äº†ï¼Œå¤§ä½“è°ƒç”¨é“¾è·¯æ˜¯`ViewRootImpl#setView` -> `ViewRootImpl#requestLayout` -> `ViewRootImpl#scheduleTraversals`

çœ‹ä¸‹scheduleTraversalsæ–¹æ³•ä»£ç 

```java
 void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
          	// â‘ 
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            if (!mUnbufferedInputDispatch) {
                scheduleConsumeBatchedInput();
            }
            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        }
    }
```

è°ƒç”¨äº†æ¶ˆæ¯é˜Ÿåˆ—çš„`postSyncBarrier`æ–¹æ³•ï¼Œè¿›å»çœ‹çœ‹

```java
		/**
		* @hide  
		*/
		public int postSyncBarrier() {
        return postSyncBarrier(SystemClock.uptimeMillis());
    }

    private int postSyncBarrier(long when) {
        // Enqueue a new sync barrier token.
        // We don't need to wake the queue because the purpose of a barrier is to stall it.
        synchronized (this) {
            final int token = mNextBarrierToken++;
          	//â‘ 
            final Message msg = Message.obtain();
            msg.markInUse();
            msg.when = when;
            msg.arg1 = token;

            Message prev = null;
            Message p = mMessages;
          	// â‘¡
            if (when != 0) {
                while (p != null && p.when <= when) {
                    prev = p;
                    p = p.next;
                }
            }
            if (prev != null) { // invariant: p == prev.next
                msg.next = p;
                prev.next = msg;
            } else {
                msg.next = p;
                mMessages = msg;
            }
            return token;
        }
    }
```

â‘  å‘ç°åˆ›å»ºäº†Messageå¯¹è±¡ï¼Œä½†æ²¡æœ‰è®¾ç½®targetå±æ€§ã€‚é€šè¿‡å‰é¢å¯¹handlerçš„åˆ†æçŸ¥é“ï¼Œloopæ–¹æ³•åˆ†å‘ç»™handleræ‰§è¡Œå®Œåä¼šå›æ”¶messageå¯¹è±¡ï¼Œå³` msg.recycleUnchecked();`ï¼Œå®ƒä¼šå°†messageå¯¹è±¡çš„æ‰€æœ‰å±æ€§ç½®ç©ºã€‚

â‘¡ è¿™ä¸€æ­¥è·Ÿæ™®é€šçš„æ¶ˆæ¯å…¥é˜Ÿç›®çš„ä¸€æ ·ï¼Œå°±æ˜¯æŠŠè¿™ä¸ªåŒæ­¥å±éšœæ¶ˆæ¯æŒ‰ç…§whenå€¼å¤§å°æ’å…¥åˆ°é“¾è¡¨ï¼Œwhenè¶Šå¤§è¶Šé è¿‘é“¾è¡¨å°¾éƒ¨ã€‚ç”±äºåŒæ­¥å±éšœæ¶ˆæ¯è®¾ç½®çš„whenæ˜¯ç³»ç»Ÿå¯åŠ¨ä»¥æ¥çš„æ—¶é—´ï¼Œéå¸¸é•¿ï¼Œæ‰€ä»¥ä¸€èˆ¬æ¥è¯´åŒæ­¥å±éšœæ¶ˆæ¯åŸºæœ¬éƒ½æ’å…¥åœ¨å°¾éƒ¨ã€‚

**ç¬¬ä¸€ä¸ªé—®é¢˜ä»€ä¹ˆæ¶ˆæ¯çš„targetæ˜¯nullï¼Œé‚£å°±æ˜¯postSyncBarrierå‘é€çš„åŒæ­¥å±éšœæ¶ˆæ¯**

è®¾ç½®åŒæ­¥å±éšœåä»£ç ç»§ç»­æ‰§è¡Œï¼Œæ‰§è¡Œ `mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);`

ä¸€ç›´æ·±å…¥postCallbackæŸ¥çœ‹ï¼Œå‘ç°æ‰§è¡Œåˆ°äº†`postCallbackDelayedInternal`æ–¹æ³•

```java
private void postCallbackDelayedInternal(int callbackType,
            Object action, Object token, long delayMillis) {
       	......	

        synchronized (mLock) {
            final long now = SystemClock.uptimeMillis();
            final long dueTime = now + delayMillis;
            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);

            if (dueTime <= now) {
                scheduleFrameLocked(now);
            } else {
              	// *
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
                msg.arg1 = callbackType;
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, dueTime);
            }
        }
    }
```

*ï¼š**åˆ›å»ºäº†çœŸæ­£ç»˜åˆ¶é¡µé¢çš„æ¶ˆæ¯å¯¹è±¡ï¼Œå¹¶ä¸”è°ƒç”¨`setAsynchronous()`å°†æ¶ˆæ¯è®¾ç½®ä¸ºäº†å¼‚æ­¥**

æ‰€ä»¥ç¬¬äºŒä¸ªé—®é¢˜ä»€ä¹ˆæ—¶å€™è®¾ç½®æ¶ˆæ¯ä¸ºå¼‚æ­¥ä¹ŸçŸ¥é“äº†ã€‚

æ€»ç»“ï¼š**å¯¹äºå¼‚æ­¥æ¶ˆæ¯ï¼ŒLooperä¼šéå†æ¶ˆæ¯é˜Ÿåˆ—æ‰¾åˆ°å¼‚æ­¥æ¶ˆæ¯æ‰§è¡Œï¼Œç¡®ä¿åƒåˆ·æ–°å±å¹•ç­‰é«˜ä¼˜ä»»åŠ¡åŠæ—¶å¾—åˆ°æ‰§è¡Œã€‚åŒæ­¥æ¶ˆæ¯å¾—ä¸åˆ°å¤„ç†ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆå«åŒæ­¥å±éšœçš„åŸå› ã€‚å½“ä½¿ç”¨äº†åŒæ­¥å±éšœï¼Œè®°å¾—é€šè¿‡`removeSyncBarrier`ç§»é™¤ï¼Œä¸ç„¶åŒæ­¥æ¶ˆæ¯ä¸èƒ½æ­£å¸¸æ‰§è¡Œã€‚**

**å½“ç„¶ï¼Œæ­£å¸¸æƒ…å†µå¼€å‘è€…ä¹Ÿä¸èƒ½æ‰‹åŠ¨å‘é€å’Œç§»é™¤åŒæ­¥å±éšœï¼Œå› ä¸ºå®ƒä»¬éƒ½è¢«hideæ³¨é‡Šäº†ã€‚ä¸è¿‡äº†è§£è¿™ä¸€æœºåˆ¶å’Œå…¶ä¸­è•´å«çš„ç¼–ç¨‹æ€ç»´è¿˜æ˜¯å¾ˆæœ‰è£¨ç›Šçš„**

# ä¸‰ã€IdleHandler

IdleHandleræä¾›äº†ä¸€ç§åœ¨æ¶ˆæ¯é˜Ÿåˆ—ç©ºé—²æ—¶æ‰§è¡Œçš„æŸäº›æ“ä½œçš„æ‰‹æ®µï¼Œé€‚ç”¨äºæ‰§è¡Œä¸€äº›ä¸é‡è¦ä¸”ä½ä¼˜å…ˆçº§çš„ä»»åŠ¡ã€‚å®ƒçš„ä½¿ç”¨ä¹Ÿå¾ˆç®€å•è°ƒç”¨`MessageQueue#addIdleHandler`æ–¹æ³•å°†ä»»åŠ¡æ·»åŠ åˆ°æ¶ˆæ¯é˜Ÿåˆ—ï¼Œç„¶åé˜Ÿåˆ—ç©ºé—²æ—¶ä¼šè‡ªåŠ¨æ‰§è¡Œï¼Œå¯é€šè¿‡`removeIdleHandler`æ–¹æ³•æˆ–è‡ªåŠ¨å›æ”¶ã€‚

æ¶ˆæ¯é˜Ÿåˆ—é€šè¿‡ä¸€ä¸ªArrayListæ¥å‚¨å­˜æ·»åŠ çš„IdleHandlerä»»åŠ¡ã€‚

```java
private final ArrayList<IdleHandler> mIdleHandlers = new ArrayList<IdleHandler>();
// ä¸´æ—¶å‚¨å­˜IdleHandlerä»»åŠ¡
private IdleHandler[] mPendingIdleHandlers;
```

è°ƒç”¨IdleHandlerä»»åŠ¡çš„ä½ç½®åœ¨`MessageQueue#next()`æ–¹æ³•ä¸­ï¼Œæ— å…³ä»£ç å·²çœç•¥

```java
Message next() {
				// â‘ 
        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        for (;;) {
           	......
            synchronized (this) {
              	// çœç•¥éƒ¨åˆ†ä¸ºè·å–æ¶ˆæ¯å¯¹è±¡çš„è¿‡ç¨‹
                .....
                  
                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
                // â‘¡
                if (pendingIdleHandlerCount < 0
                        && (mMessages == null || now < mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount <= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    mBlocked = true;
                    continue;
                }
				//â‘¢
                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
          	// â‘£
            for (int i = 0; i < pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG, "IdleHandler threw exception", t);
                }

                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }
			// â‘¤
            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;

            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            nextPollTimeoutMillis = 0;
        }
    }
```

â‘  æ¯æ¬¡Looperè°ƒç”¨`next`æ–¹æ³•æ—¶ï¼Œå…ˆå°†IdleHandlerä¸´æ—¶æ•°ç»„çš„å¤§å°`pendingIdleHandlerCount`é‡ç½®ä¸º -1ã€‚

â‘¡ é¦–æ¬¡è¿è¡Œæ—¶`pendingIdleHandlerCount < 0`è‚¯å®šæˆç«‹ï¼Œå¦‚æœå½“å‰æ¶ˆæ¯é˜Ÿåˆ—ä¸ºç©ºæˆ–è€…åªæœ‰å»¶æ—¶æ¶ˆæ¯æ—¶ï¼Œè®¤ä¸ºæ­¤æ—¶é˜Ÿåˆ—ç©ºé—²å¯ä»¥æ‰§è¡ŒIdleHandlerä»»åŠ¡äº†ã€‚ä»¤`pendingIdleHandlerCount`ä¸ºå·²æ·»åŠ çš„IdleHandlerä»»åŠ¡ä¸ªæ•°ã€‚

â‘¢ `mPendingIdleHandlers`æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œé¦–æ¬¡æ‰§è¡Œæ—¶å¯å®šä¸ºç©ºï¼Œæ‰€ä»¥åˆå§‹åŒ–æ•°ç»„ï¼Œæ•°ç»„å¤§å°æœ€å°ä¸º4ã€‚å¹¶ä¸”å°†`mIdleHandlers`åˆ—è¡¨ä¸­çš„ä»»åŠ¡å¤åˆ¶åˆ°è¿™ä¸ªä¸´æ—¶æ•°ç»„ã€‚

â‘£ å¾ªç¯ä¸´æ—¶æ•°ç»„æ‰§è¡ŒIdleHandlerä»»åŠ¡ï¼Œä»»åŠ¡ä»`mPendingIdleHandlers`æ•°ç»„ä¸­å–å‡ºåï¼Œä¼šç½®ç©ºï¼Œé‡Šæ”¾å¯¹handlerå¯¹è±¡çš„å¼•ç”¨ã€‚ç„¶åè°ƒç”¨`queueIdle()`çœŸæ­£æ‰§è¡ŒIdleHandlerä»»åŠ¡ã€‚

`queueIdle()`æ˜¯ä¸€ä¸ªæ¥å£æ–¹æ³•ï¼Œéœ€è¦è‡ªå·±å®ç°ä¸šåŠ¡é€»è¾‘ã€‚å¦å¤–å®ƒçš„è¿”å›å€¼å†³å®šæ˜¯å¦è¦è‡ªåŠ¨åˆ é™¤è¯¥IdleHandlerä»»åŠ¡ï¼Œè¿”å›trueè¯¥ä»»åŠ¡æ‰§è¡Œåå°†ä¸ä¼šè¢«åˆ é™¤

â‘¤ é‡ç½®`mPendingIdleHandlers = 0`ï¼Œå¼€å¯ä¸‹æ¬¡å¾ªç¯ã€‚

# å››ã€æ¶ˆæ¯å¯¹è±¡æ± 

æ¶ˆæ¯æ˜¯æ•°æ®çš„è½½ä½“ï¼Œæˆ‘ä»¬çŸ¥é“åˆ›å»ºæ¶ˆæ¯å¯¹è±¡æ˜¯ä¸€èˆ¬ä¸æå€¡å»`new`ä¸€ä¸ªå¯¹è±¡ï¼Œè€Œæ˜¯è°ƒç”¨Messageçš„ä¸€ç³»åˆ—`obtain`çš„é‡è½½æ–¹æ³•ï¼ŒåŸå› å°±æ˜¯å› ä¸ºå¯ä»¥å¤ç”¨å·²åˆ›å»ºçš„Messageå¯¹è±¡ï¼Œé¿å…åˆ›å»ºè¿‡å¤šå¯¹è±¡å æ®å¤§é‡å†…å­˜ã€‚æ—¢ç„¶æ˜¯å¤ç”¨ï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨æŸç§æ•°æ®ç»“æ„å»ä¿å­˜å¯¹è±¡ï¼Œè¿™å°±æ˜¯æ¶ˆæ¯å¯¹è±¡æ± ï¼Œä½¿ç”¨çš„æ˜¯é“¾è¡¨ç»“æ„ã€‚

## 3.1 åˆ›å»ºMessageå¯¹è±¡

æ¶ˆæ¯å¯¹è±¡æ± æœ‰å‡ ä¸ªé‡è¦å±æ€§ï¼Œåˆ†åˆ«æ˜¯ï¼š

```java
	 // åŒæ­¥å¯¹è±¡
	public static final Object sPoolSync = new Object();
	// é“¾è¡¨å¤´èŠ‚ç‚¹
    private static Message sPool;
		// æ¶ˆæ¯æ± å¤§å°ï¼ˆé“¾è¡¨é•¿åº¦ï¼Œè¡¨ç¤ºæ¶ˆæ¯ä¸ªæ•°ï¼‰
    private static int sPoolSize = 0;
		// æ¶ˆæ¯æ± æœ€å¤§å®¹é‡
    private static final int MAX_POOL_SIZE = 50;
```

çœ‹ä¸‹`obtain`æ–¹æ³•

```java
public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
```

ä»£ç å¾ˆç®€æ´ï¼Œè·å–æ¶ˆæ¯å¯¹è±¡æ˜¯åŒæ­¥æ“ä½œï¼Œä»å¤´èŠ‚ç‚¹å¼€å§‹ï¼Œå¦‚æœå¤´ç»“ç‚¹ä¸ä¸ºç©ºï¼Œå–å¾—å¤´ç»“ç‚¹ã€‚ç„¶åæŒ‡é’ˆåç§»ï¼Œå¹¶ä¸”æ¶ˆæ¯æ± å¤§å°å‡1ã€‚å¦åˆ™çš„æ‰é€šè¿‡`new`æ–¹å¼åˆ›å»ºæ–°å¯¹è±¡ã€‚

## 3.2 å›æ”¶Messageå¯¹è±¡

å¯ä»¥è°ƒç”¨`recycle`æ–¹æ³•å›æ”¶æ¶ˆæ¯å¯¹è±¡

```java
public void recycle() {
        if (isInUse()) {
            if (gCheckRecycle) {
                throw new IllegalStateException("This message cannot be recycled because it "+ "is still in use.");
            }
            return;
        }
        recycleUnchecked();
    }
```

å¦‚æœæ¶ˆæ¯æ ‡è®°äº†`FLAG_IN_USE`æ ‡å¿—ï¼Œä¸å¯å›æ”¶ã€‚ç„¶åçœŸæ­£å›æ”¶çš„æ–¹æ³•æ˜¯`recycleUnchecked();`

```java
void recycleUnchecked() {
        // Mark the message as in use while it remains in the recycled object pool.
        // Clear out all other details.
        flags = FLAG_IN_USE;
        what = 0;
        arg1 = 0;
        arg2 = 0;
        obj = null;
        replyTo = null;
        sendingUid = UID_NONE;
        workSourceUid = UID_NONE;
        when = 0;
        target = null;
        callback = null;
        data = null;

        synchronized (sPoolSync) {
            if (sPoolSize < MAX_POOL_SIZE) {
                next = sPool;
                sPool = this;
                sPoolSize++;
            }
        }
    }
```

å¯è§å›æ”¶æ¶ˆæ¯ï¼Œé¦–å…ˆå°±æ˜¯å°†å…¶æˆå‘˜å˜é‡å…¨éƒ¨é‡ç½®ä¸ºåˆå§‹å€¼ï¼Œç„¶ååœ¨æ¶ˆæ¯æ± å¤§å°ä¸è¶…è¿‡é™åˆ¶å®¹é‡æ—¶ï¼Œè®©å°†è¦è¢«å›æ”¶èŠ‚ç‚¹çš„`next`æŒ‡å‘å¤´ç»“ç‚¹ï¼Œå†æŠŠå¤´æŒ‡é’ˆç§»åˆ°å½“å‰èŠ‚ç‚¹ï¼Œå®¹é‡åŠ 1ã€‚

# äº”ã€æ€»ç»“

æœ¬æ–‡ä»Handleræ¶ˆæ¯æœºåˆ¶å‡ºå‘ï¼Œåˆ†æäº†æ¶ˆæ¯ä»å‘é€ã€è°ƒåº¦å’Œåˆ†å‘å¤„ç†çš„å…¨è¿‡ç¨‹ã€‚åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œå‘ç°æ¶‰åŠåˆ°äº†åŒæ­¥å±éšœã€IdleHandlerç­‰çŸ¥è¯†ç‚¹ï¼Œå¹¶å¯¹å…¶åšäº†åˆ†æå’Œè¯´æ˜ã€‚æœ‰äº›ä¸œè¥¿å¯èƒ½åœ¨å¹³æ—¶å¼€å‘ä¸­ç”¨ä¸ä¸Šï¼Œä¾‹å¦‚æ¶ˆæ¯å±éšœï¼Œä½†å…¶è•´å«çš„ç¼–ç¨‹æ€æƒ³ä¹Ÿæ˜¯ååˆ†å€¼å¾—å­¦ä¹ å€Ÿé‰´çš„ã€‚